---
title: Solve the GPE in a 1D parabolic trap
author: Ashton Bradley
---

# Introduction
In this simple example we start by finding the ground state of the Gross-Pitaevskii equation
in a harmonic trap.

The mean field order parameter evolves according to the GP-equation
$$
i\hbar\frac{\partial \psi(x,t)}{\partial t}=\left(-\frac{\hbar^2\partial_x^2}{2m}+V(x,t)+g|\psi(x,t)|^2\right)\psi(x,t)
$$
with potential $V(x,t)=m\omega_x^2 x^2/2$, and positive interaction strength $g$.

The equation of motion solved numerically is
$$
i\frac{\partial \psi(x,t)}{\partial t}=\left(-\frac{\partial_x^2}{2}+V(x,t)+g|\psi(x,t)|^2\right)\psi(x,t)
$$
raising the question of units. We work in trap units, taking length in units of $a_x=\sqrt{\hbar/m\omega_x}$ and time in
units of $1/\omega_x$.

# Loading the package
First, we load some useful packages.
```julia
using Plots, LaTeXStrings
gr(fmt="png",legend=false,titlefontsize=12,size=(500,200),grid=false,transpose=true,colorbar=false);
```
Now load `FourierGPE`
```julia
using FourierGPE
```
Let's define a convenient plot function
```julia
function showpsi(x,ψ)
    p1 = plot(x,abs2.(ψ))
    xlabel!(L"x/a_x");ylabel!(L"|\psi|^2")
    p2 = plot(x,angle.(ψ))
    xlabel!(L"x/a_x");ylabel!(L"\textrm{phase}(\psi)")
    p = plot(p1,p2,layout=(2,1),size=(600,400))
    return p
end
```

Let's set the system size, and number of spatial points and initialize default simulation
```julia
L = (40.0,)
N = (512,)
sim = Sim(L,N)
@unpack_Sim sim;
μ = 25.0
```
Here we keep most of the default parameters but increase the chemical potential.

## Declaring the potential
Let's define the trapping potential.
```julia
import FourierGPE.V
V(x,t) = 0.5*x^2
```
We only require the definition as a scalar function
because it will be evaluated on the grid using a broadcasted dot-call.

# Initial condition
Let's define a useful Thomas-Fermi wavefunction
```julia
ψ0(x,μ,g) = sqrt(μ/g)*sqrt(max(1.0-V(x,0.0)/μ,0.0)+im*0.0)
x = X[1];
```
The initial state is now created on the grid and all modified variables are scooped up into `sim`:
```julia
ψi = ψ0.(x,μ,g)
ϕi = kspace(ψi,sim)
@pack_Sim! sim;
sim
```

# Evolution in k-space
The `FFTW` library is used to evolve the Gross-Pitaevskii equation in k-space
```julia
sol = runsim(sim);
```
By default the solver returns all time slices and solution information in a single variable `sol`.

Let's have a look at the final state and verify we have a ground state (note above that $\gamma=0.5$ is default)
```julia
ϕg = sol[end]
ψg = xspace(ϕg,sim)
p=plot(x,g*abs2.(ψg),fill=(0,0.2),size=(500,200))
plot!(x,one.(x)*μ)
plot!(x,V.(x,0.0))
xlims!(-10,10); ylims!(0,1.3*μ)
title!(L"\textrm{local}\; \mu(x)")
xlabel!(L"x/a_x"); ylabel!(L"\mu(x)/\hbar\omega_x")
plot(p)
```

The initial Thomas-Fermi state has been evolved for a default time $t=2/\gamma$ which is
a characteristic damping time for the dissipative system with dimensionless damping
$\gamma$. The solution will approch the ground state satisfying $L\psi_0=\mu\psi_0$ on a timescale of order
$1/\gamma$. The figure shows a smooth density profile and a completely homogeneous phase
profile over the region of finite atomic density, as required for the ground state. The indeterminate
phase evident at large $|x|$ is unimportant.

## Default simulation parameters
The default parameters are given in the declaration of `Sim`, which allows (sequential) parameter dependence.
The struct `Sim` is declared as:

```julia; eval = false
@with_kw mutable struct Sim{D} <: Simulation{D} @deftype Float64
    # Add more parameters as necessary, or add to params (see examples)
    L::NTuple{D,Float64} # box length scales
    N::NTuple{D,Int64}  # grid points in each dimensions
    μ = 15.0    # chemical potential
    g = 0.1     # interaction parameter
    γ = 0.5; @assert γ >= 0.0 # damping parameter
    ti = 0.0    # initial time
    tf = 2/γ    # final time
    Nt::Int64 = 200     # number of saves over (ti,tf)
    params::UserParams = Params() # optional user parameters
    V0::Array{Float64,D} = zeros(N)
    t::LinRange{Float64} = LinRange(ti,tf,Nt) # time of saves
    ϕi::Array{Complex{Float64},D} = zeros(N) |> complex # initial condition
    alg::OrdinaryDiffEq.OrdinaryDiffEqAdaptiveAlgorithm = Tsit5() # default solver
    reltol::Float64 = 1e-6 # default tolerance; may need to use 1e-7 for corner cases
    flags::UInt32 = FFTW.MEASURE # choose a plan. PATIENT, NO_TIMELIMIT, EXHAUSTIVE
    nfiles::Bool = false
    path::String = nfiles ? joinpath(@__DIR__,"data") : @__DIR__
    filename::String = "save"
    # =======================================
    # arrays, transforms, spectral operators
    X::NTuple{D,Array{Float64,1}} = xvecs(L,N)
    K::NTuple{D,Array{Float64,1}} = kvecs(L,N)
    espec::Array{Complex{Float64},D} = 0.5*k2(K)
    T::TransformLibrary = makeT(X,K,flags=flags)
end
```

where we see a set of default parameters, and then some useful transform fields built using the parameters.
Note that the transforms have to be built after constructing `X,K`.

# Dark soliton in harmonically trapped system
We found a ground state by imaginary time propagation.
Now we can impose a phase and density imprint consistent with a dark soliton.
We will use the solution for the homogeneous system, which will be a reasonable
approximation if we impose it on a smooth background solution.

## Imprinting a dark soliton
```julia
ψf = xspace(sol[end],sim)
c = sqrt(μ)
ξ = 1/c
v = 0.5*c
xs = 0.
f = sqrt(1-(v/c)^2)
```
Soliton speed is determined by depth and local healing length, and is intialized at `xs=0.0`.
```julia
ψs = @. ψf*(f*tanh(f*(x -xs)/ξ)+im*v/c)
showpsi(x,ψs)
xlims!(-10,10)
```
## Initilize Simulation
We can recycle our earlier parameter choices, modifying the damping and simulation timescale
```julia
γ = 0.0
tf = 8*pi/sqrt(2); t = LinRange(ti,tf,Nt)
dt = 0.01π/μ
simSoliton = Sim(sim;γ=γ,tf=tf,t=t)
ϕi = kspace(ψs,simSoliton)
@pack_Sim! simSoliton;
```

## Solve equation of motion
As before, we specify the initial condition in momentum space, and evolve
```julia
sols = runsim(simSoliton);
```

## View the solution using Plots
Plots allows easy creation of an animated gif, as in the runnable example code below.
```julia; eval = false
ϕf = sols[end-4]
ψf = xspace(ϕf,simSoliton)
showpsi(x,ψf)

anim = @animate for i in 1:length(t)-4
    ψ = xspace(sols[i],simSoliton)
    y = g*abs2.(ψ)
    p = plot(x,y,fill=(0,0.2),size=(500,200))
    xlims!(-10,10); ylims!(0,1.3*μ)
    title!(L"\textrm{local}\; \mu(x)")
    xlabel!(L"x/a_x"); ylabel!(L"\mu(x)/\hbar\omega_x")
end
animpath = joinpath(@__DIR__,"media/soliton.gif")
gif(anim,animpath,fps=30)
```
The result is visible in the media folder.

Here we simply plot the final state:
```julia
ψ = xspace(sols[end],simSoliton)
y = g*abs2.(ψ)
p=plot(x,y,fill=(0,0.2),size=(500,200))
xlims!(-10,10); ylims!(0,1.3*μ)
title!(L"\textrm{local}\; \mu(x)")
xlabel!(L"x/a_x"); ylabel!(L"\mu(x)/\hbar\omega_x")
plot(p)
```
